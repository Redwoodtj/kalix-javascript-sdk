= Implementing value entities

This page documents how to implement Akka Serverless value entities in JavaScript.
// FIXME concept link if we should have one
// For information on what Akka Serverless value entities are, please read the general
// xref:concepts:valueentities.adoc[Value entities] documentation first.

== State types and serialization

Value entities persist their state on every change, and it needs to be serialized when persisted. The most straight forward way to persist the state is to use protobufs. Akka Serverless will automatically detect if an updated state is protobuf, and serialize it as such using `protobufjs`. See https://www.npmjs.com/package/protobufjs for more information on `protobufjs`. For other serialization options, including JSON, see xref:serialization.adoc[Serialization].

While protobufs are the recommended format for persisting the state, it is recommended that you do not persist your service's protobuf messages as state. While this may introduce some overhead in needing to convert from one type to the other, the reason for doing this is that it will allow the service's public interface to evolve independently from its data storage format, which should be private.

For our shopping cart example, we'll create a new file called `domain.proto`, the name domain is selected to indicate that these are my application's domain objects:

[source,protobuf]
----
include::example$domain.proto[tag=valueentity]
----

In this file, the message `Cart` is the state, containing a collection of `LineItems`.

== Creating an entity

A value entity can be created using the link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.html[ValueEntity] class.

// FIXME waiting for example
[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=entity-class]
----

Here we pass in the protobuf files that contain our service and our domain protocol, `shoppingcart.proto` and `domain.proto`. Akka Serverless needs the protobuf file that your service lives in so that it can load it and read it. It also needs the protobuf file that your domain state are in so that when it receives the state from the proxy, and can know how to deserialize it.

We also pass in the fully qualified name of the service our value entity implements, `example.shoppingcart.ShoppingCartService`. We also are specifying some options.

The `persistenceId` is used to namespace the state in the journal, useful for when you share the same database between multiple entities. It defaults to `entity`, so it's a good idea to select one explicitly.

== Using protobuf types

When you pass the state to Akka Serverless to persist, it needs to know how to serialize that. Simply passing a regular object does not provide enough information to know how protobuf should serialize the objects. Hence, any state types that you want to use, you have to lookup the protobuf type for, and then use the `create` method to create it.

The `ValueEntity` class provides a helper method called link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.html#lookupType[`lookupType`] to facilitate this. So before implementing anything, we'll look up these types so we can use them later.

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=lookup-type]
----

== Initial state

When there is no state persisted for an entity (such as when the entity is first created), the entity needs to have an initial state. Note that value entities are not explicitly created, they are implicitly created when a command arrives for them. Additionally, creating an entity doesn't mean anything is persisted, nothing is persisted until a state is persisted for that entity. So, if user "X" opens their shopping cart for the first time, an entity will be created, but it will have nothing stored yet, and just be in the initial state.

To create the initial state, we set the link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.html#initial[`initial`] callback. This takes the id of the entity being created, and returns a new empty state, in this case, an empty shopping cart:

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=initial]
----

Note the use of `Cart.create()`, this creates a protobuf message using the `Cart` protobuf message type that we looked up earlier.

== Behavior

Now we need to define the behavior for our entity. The behavior consists a single part, the command handlers.


=== Command handlers

A link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.html#~commandHandler[command handler] is a function that takes a command, the current state, and an link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.ValueEntityCommandContext.html[`ValueEntityCommandContext`]. It implements a service call on the entities gRPC interface.

The command is the input message type for the gRPC service call. For example, the `GetCart` service call has an input type of `GetShoppingCart`, while the `AddItem` service call has an input type of `AddLineItem`. The command will be an object that matches the structure of these protobuf types.

The command handler must return a message of the same type as the output type of the gRPC service call, in the case of our `GetCart` command, this must be a `Cart` message. Note that unlike for the state, this message does not need to be created using a looked up protobuf message type - Akka Serverless already knows the output type of the gRPC service call and so can infer it itself. It only has to be a plain JavaScript object that matches the structure of the protobuf type.

The following shows the implementation of the `GetCart` command handler. This command handler is a read-only command handler, it doesn't update the state, it just returns it:

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=get-cart]
----

==== Updating the state

When updating the state a command handler MUST persist that change by calling  link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.ValueEntityCommandContext.html#updateState[`updateState`] method on the `ValueEntityCommandContext`. If it does not, any change to the state will be *lost* when the next command arrives.

Here's an example of a command handler updates the state:

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=add-item]
----

This command handler also validates the command, ensuring the quantity items added is greater than zero. Invoking link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.ValueEntityCommandContext.html#fail[`fail`] fails the command - this method throws so there's no need to explicitly throw an exception.

// FIXME should we have something about changing behavior with setCommandHandler as well?
// == Changing behavior

== Starting the entity

If you only have a single entity, as a convenience, you can start it directly, by invoking the link:{attachmentsdir}/api/module-akkaserverless.ValueEntity.html#start[`start`] method, like so:

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=start]
----

Alternatively, you can add it to the `AkkaServerless` server explicitly:

[source,js]
----
include::example$test/valueentity/shoppingcart.js[tag=add-entity]
----
